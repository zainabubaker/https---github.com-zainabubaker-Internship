Floating Point Arithmetic Lec 14 Systems Architecture 1 Introduction • Objective : To provide hardware support for floating point arithmetic . To understand how to represent floating point numbers in the computer and how to perform arithmetic with them . Also to learn how to use floating point arithmetic in MIPS . • Approximate arithmetic – Finite Range – Limited Precision • Topics – IEEE format for single and double precision floating point numbers – Floating point addition and multiplication – Support for floating point computation in MIPS Lec 14 Systems Architecture 2 Floating Point • An IEEE floating point representation consists of – A Sign Bit ( no surprise ) – An Exponent ( “ times 2 to the what ? ” ) – Mantissa ( “ Significand ” ) , which is assumed to be 1.xxxxx ( thus , one bit of the mantissa is implied as 1 ) – This is called a normalized representation • So a mantissa = 0 really is interpreted to be 1.0 , and a mantissa of all 1111 is interpreted to be 1.1111 • Special cases are used to represent 0 , infinity and NaN . Lec 14 Systems Architecture 3 Floating Point Standard • Defined by IEEE Std 754-1985 • Developed in response to divergence of representations – Portability issues for scientific code • Now almost universally adopted • Two representations – Single precision ( 32-bit ) – Double precision ( 64-bit ) Lec 14 Systems Architecture 4 IEEE Floating-Point Format single : 8 bits double : 11 bits single : 23 bits double : 52 bits S Exponent Fraction/Mantissa ( x  1 ) S ( 1  Fraction )  2 ( Exponent  Bias ) • S : sign bit ( 0  non-negative , 1  negative ) • Normalize significand : 1.0 ≤ |significand| < 2.0 – Always has a leading pre-binary-point 1 bit , so no need to represent it explicitly ( hidden bit ) – Significand is Fraction with the “ 1. ” restored • Exponent : excess representation : actual exponent + Bias – Ensures exponent is unsigned – Single : Bias = 127 ; Double : Bias = 1023 Lec 14 Systems Architecture 5 Representation of Floating Point Numbers • IEEE 754 single precision 31 30 23 22 0 Sign Biased exponent Normalized Mantissa ( implicit 24th bit = 1 ) ( -1 ) s  F  2E-127 Exponent Mantissa Object Represented 0 1-254 255 255 0 anything 0 non-zero 0 FP number infinity NaN Lec 14 Systems Architecture 6 Basic Technique • Represent the decimal in the form +/- 1.xxxb x 2y • And “ fill in the fields ” – Remember biased exponent and implicit “ 1. ” mantissa ! • Examples : – 0.0 : 0 00000000 00000000000000000000000 – 1.0 ( 1.0 x 2^0 ) : 0 01111111 00000000000000000000000 – 0.5 ( 0.1 binary = 1.0 x 2^-1 ) : 0 01111110 00000000000000000000000 – 0.75 ( 0.11 binary = 1.1 x 2^-1 ) : 0 01111110 10000000000000000000000 – 3.0 ( 11 binary = 1.1 * 2^1 ) : 0 10000000 10000000000000000000000 – -0.375 ( -0.011 binary = -1.1 * 2^-2 ) : 1 01111101 10000000000000000000000 – 1 10000011 01000000000000000000000 = - 1.01 * 2^4 = -20.0 Lec 14 Systems Architecture http : //www.math-cs.gordon.edu/courses/cs311/lectures-2003/binary.html Copyright ©2003 - Russell C. Bjork 7 Floating-Point Example • What number is represented by the single-precision float 11000000101000…00 – S = 1 – Fraction = 01000…002 – Fxponent = 100000012 = 129 • x = ( –1 ) 1 × ( 1 + 012 ) × 2 ( 129 – 127 ) = ( –1 ) × 1.25 × 22 = –5.0 Lec 14 Systems Architecture 8 Floating-Point Example • Represent –0.75 – –0.75 = ( –1 ) 1 × 1.12 × 2–1 – S = 1 – Fraction = 1000…002 – Exponent = –1 + Bias • Single : –1 + 127 = 126 = 011111102 • Double : –1 + 1023 = 1022 = 011111111102 • Single : 1011111101000…00 • Double : 1011111111101000…00 Lec 14 Systems Architecture 9 Infinities and NaNs • Exponent = 111 ... 1 , Fraction = 000 ... 0 – ±Infinity – Can be used in subsequent calculations , avoiding need for overflow check • Exponent = 111 ... 1 , Fraction ≠ 000 ... 0 – Not-a-Number ( NaN ) – Indicates illegal or undefined result • e.g. , 0.0 / 0.0 – Can be used in subsequent calculations Lec 14 Systems Architecture 10 Single-Precision Range • Exponents 00000000 and 11111111 reserved • Smallest value – Exponent : 00000001  actual exponent = 1 – 127 = –126 – Fraction : 000…00  significand = 1.0 – ±1.0 × 2–126 ≈ ±1.2 × 10–38 • Largest value – exponent : 11111110  actual exponent = 254 – 127 = +127 – Fraction : 111…11  significand ≈ 2.0 – ±2.0 × 2+127 ≈ ±3.4 × 10+38 Lec 14 Systems Architecture 11 Double-Precision Range • Exponents 0000…00 and 1111…11 reserved • Smallest value – Exponent : 00000000001  actual exponent = 1 – 1023 = –1022 – Fraction : 000…00  significand = 1.0 – ±1.0 × 2–1022 ≈ ±2.2 × 10–308 • Largest value – Exponent : 11111111110  actual exponent = 2046 – 1023 = +1023 – Fraction : 111…11  significand ≈ 2.0 – ±2.0 × 2+1023 ≈ ±1.8 × 10+308 Lec 14 Systems Architecture 12 Representation of Floating Point Numbers 64 63 53 52 0 Sign Biased exponent Normalized Mantissa ( implicit 53rd bit ) Exponent Mantissa Object Represented 0 1-2046 2047 2047 0 anything 0 non-zero 0 FP number pm infinity NaN ( -1 ) s  F  2E-1023 Lec 14 Systems Architecture 13 Floating-Point Precision • Relative precision – all fraction bits are significant – Single : approx 2–23 • Equivalent to 23 × log102 ≈ 23 × 0.3 ≈ 6 decimal digits of precision – Double : approx 2–52 • Equivalent to 52 × log102 ≈ 52 × 0.3 ≈ 16 decimal digits of precision Lec 14 Systems Architecture 14 Floating Point Addition Lec 14 Systems Architecture Floating point addition Sign Exponent Fraction Sign Exponent Fraction • Small ALU Exponent difference 0 1 0 1 0 1 Control Shift right Big ALU 0 1 0 1 Increment or decrement Shift left or right Rounding hardware Sign Exponent Fraction Sta r t 1 . C o m p a re th e ex po n e n ts of th e tw o n u m b e rs . S h ift th e sm a lle r n u m b er to th e rig h t u n til its ex po n en t w o uld m a tc h th e la rg e r ex p o n e nt 2 . A d d th e s ig n ifica n d s 3 . N o rm a lize th e su m , e ith e r sh ifting rig ht a n d in cre m e n ting th e ex p o n e nt or s h iftin g le ft a n d d e cre m e n tin g th e ex p o n en t O ve rflow o r u n d e rflow ? Ye s N o E xc e p tio n 4 . R o u n d the s ig n ific a n d to th e a pp ro pr ia te n u m b er o f b its N o Still n o r m a lize d ? Ye s D o n e Lec 14 Systems Architecture 16 Floating-Point Addition • Consider a 4-digit decimal example – 9.999 × 101 + 1.610 × 10–1 • 1 . Align decimal points – Shift number with smaller exponent – 9.999 × 101 + 0.016 × 101 • 2 . Add significands – 9.999 × 101 + 0.016 × 101 = 10.015 × 101 • 3 . Normalize result & check for over/underflow – 1.0015 × 102 • 4 . Round and renormalize if necessary – 1.002 × 102 Lec 14 Systems Architecture 17 Floating-Point Addition • Now consider a 4-digit binary example – 1.0002 × 2–1 + –1.1102 × 2–2 ( 0.5 + –0.4375 ) • 1 . Align binary points – Shift number with smaller exponent – 1.0002 × 2–1 + –0.1112 × 2–1 • 2 . Add significands – 1.0002 × 2–1 + –0.1112 × 2–1 = 0.0012 × 2–1 • 3 . Normalize result & check for over/underflow – 1.0002 × 2–4 , with no over/underflow • 4 . Round and renormalize if necessary – 1.0002 × 2–4 ( no change ) = 0.0625 Lec 14 Systems Architecture 18 FP Adder Hardware • Much more complex than integer adder • Doing it in one clock cycle would take too long – Much longer than integer operations – Slower clock would penalize all instructions • FP adder usually takes several cycles – Can be pipelined Lec 14 Systems Architecture 19 FP Adder Hardware Step 1 Step 2 Step 3 Step 4 Lec 14 Systems Architecture 20 Floating Point Multiplication Lec 14 Systems Architecture Floating Point Multiplication Algorithm Lec 14 Systems Architecture 22 Floating-Point Multiplication • Consider a 4-digit decimal example – 1.110 × 1010 × 9.200 × 10–5 • 1 . Add exponents – For biased exponents , subtract bias from sum – New exponent = 10 + –5 = 5 • 2 . Multiply significands – 1.110 × 9.200 = 10.212  10.212 × 105 • 3 . Normalize result & check for over/underflow – 1.0212 × 106 • 4 . Round and renormalize if necessary – 1.021 × 106 • 5 . Determine sign of result from signs of operands – +1.021 × 106 Lec 14 Systems Architecture 23 Floating-Point Multiplication • Now consider a 4-digit binary example – 1.0002 × 2–1 × –1.1102 × 2–2 ( 0.5 × –0.4375 ) • 1 . Add exponents – Unbiased : –1 + –2 = –3 – Biased : ( –1 + 127 ) + ( –2 + 127 ) = –3 + 254 – 127 = –3 + 127 • 2 . Multiply significands – 1.0002 × 1.1102 = 1.1102  1.1102 × 2–3 • 3 . Normalize result & check for over/underflow – 1.1102 × 2–3 ( no change ) with no over/underflow • 4 . Round and renormalize if necessary – 1.1102 × 2–3 ( no change ) • 5 . Determine sign : +ve × –ve  –ve – –1.1102 × 2–3 = –0.21875 Lec 14 Systems Architecture 24 FP Arithmetic Hardware • FP multiplier is of similar complexity to FP adder – But uses a multiplier for significands instead of an adder • FP arithmetic hardware usually does – Addition , subtraction , multiplication , division , reciprocal , square-root – FP  integer conversion • Operations usually takes several cycles – Can be pipelined Lec 14 Systems Architecture 25 Advantages of IEEE 754 Standard Used predominantly by the industry Encoding of exponent and fraction simplifies comparison Integer comparator used to compare magnitude of FP numbers Includes special exceptional values : NaN and ±∞ Special rules are used such as : 0/0 is NaN , sqrt ( –1 ) is NaN , 1/0 is ∞ , and 1/∞ is 0 Computation may continue in the face of exceptional conditions FP Instructions in MIPS • Floating point operations are slower than integer operations • Data is rarely converted from integers to float within the same procedure • • 1980 ’ s solution – place FP processing unit in a separate chip Today ’ s solution – imbed FP processing unit in processor chip • Co-processor 1 features : – Contains 32 single precision floating point registers : $ f0 , $ f1 , … $ f31 – These registers can also act as 16 double precision registers : $ f0/ $ f1 , $ f2/ $ f3 , … , $ f30/ $ f31 ( only the first one is specified in the instructions ) – Uses special floating point instructions , which are similar ( in format ) to integer instructions but have .s or .d attached to signify that they work on fp numbers – Several special instructions to move between “ regular ” registers and the co- processor registers Lec 14 Systems Architecture 27 MIPS Floating Point Coprocessor Called Coprocessor 1 or the Floating Point Unit ( FPU ) 32 separate floating point registers : $ f0 , $ f1 , … , $ f31 FP registers are 32 bits for single precision numbers Even-odd register pair form a double precision register Use the even number for double precision registers $ f0 , $ f2 , $ f4 , … , $ f30 are used for double precision Separate FP instructions for single/double precision Single precision : add.s , sub.s , mul.s , div.s Double precision : add.d , sub.d , mul.d , div.d ( .s extension ) ( .d extension ) FP instructions are more complex than the integer ones Take more cycles to execute The MIPS Processor . . . 4 bytes per word Memory Up to 232 bytes = 230 words EIU 32 General Purpose Registers Arithmetic & Logic Unit ALU $ 0 $ 1 $ 2 $ 31 Execution & Integer Unit ( Main proc ) Integer mul/div Hi Lo Integer Multiplier/Divider FPU FP Arith TMU . . . F0 F1 F2 F31 Floating Point Unit ( Coproc 1 ) Trap & Memory Unit ( Coproc 0 ) BadVaddr Status Cause EPC 32 Floating-Point Registers Floating-Point Arithmetic Unit Coprocessor Instruction Set • Load word to coprocessor • Store word from coprocessor • Move to coprocessor • Move from coprocessor • Move control to coprocessor • Move control from coprocessor • Coprocessor operation • Branch on coprocessor true • Branch on coprocessor false FP Arithmetic Instructions Instruction add.s fd , fs , ft add.d fd , fs , ft sub.s fd , fs , ft sub.d fd , fs , ft mul.s fd , fs , ft mul.d fd , fs , ft fd , fs , ft div.s div.d fd , fs , ft sqrt.s fd , fs sqrt.d fd , fs abs.s fd , fs abs.d fd , fs neg.s fd , fs neg.d fd , fs Meaning ( fd ) = ( fs ) + ( ft ) ( fd ) = ( fs ) + ( ft ) ( fd ) = ( fs ) – ( ft ) ( fd ) = ( fs ) – ( ft ) ( fd ) = ( fs ) × ( ft ) ( fd ) = ( fs ) × ( ft ) ( fd ) = ( fs ) / ( ft ) ( fd ) = ( fs ) / ( ft ) ( fd ) = sqrt ( fs ) ( fd ) = sqrt ( fs ) ( fd ) = abs ( fs ) ( fd ) = abs ( fs ) ( fd ) = – ( fs ) ( fd ) = – ( fs ) Format ft5 ft5 ft5 ft5 ft5 ft5 ft5 ft5 0 0 0 0 0 0 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fs5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 fd5 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 0 1 1 2 2 3 3 4 4 5 5 7 7 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 FP Load/Store Instructions  Separate floating point load/store instructions  lwc1 : load word coprocessor 1  ldc1 : load double coprocessor 1  swc1 : store word coprocessor 1  sdc1 : store double coprocessor 1 General purpose register is used as the base register Instruction lwc1 $ f2 , 40 ( $ t0 ) ldc1 $ f2 , 40 ( $ t0 ) swc1 $ f2 , 40 ( $ t0 ) sdc1 $ f2 , 40 ( $ t0 ) Meaning ( $ f2 ) = Mem [ ( $ t0 ) +40 ] ( $ f2 ) = Mem [ ( $ t0 ) +40 ] Mem [ ( $ t0 ) +40 ] = ( $ f2 ) Mem [ ( $ t0 ) +40 ] = ( $ f2 ) Format $ f2 $ f2 $ f2 $ f2 $ t0 $ t0 $ t0 $ t0 im16 = 40 im16 = 40 im16 = 40 im16 = 40 0x31 0x35 0x39 0x3d  Better names can be used for the above instructions  l.s = lwc1 ( load FP single ) , l.d = ldc1 ( load FP double )  s.s = swc1 ( store FP single ) , s.d = sdc1 ( store FP double ) FP Data Movement Instructions  Moving data between general purpose and FP registers  mfc1 : move from coprocessor 1 ( to general purpose register )  mtc1 : move to coprocessor 1 ( from general purpose register )  Moving data between FP registers  mov.s : move single precision float  mov.d : move double precision float = even/odd pair of registers Instruction mfc1 $ t0 , $ f2 Meaning ( $ t0 ) = ( $ f2 ) mtc1 $ t0 , $ f2 ( $ f2 ) = ( $ t0 ) mov.s $ f4 , $ f2 ( $ f4 ) = ( $ f2 ) mov.d $ f4 , $ f2 ( $ f4 ) = ( $ f2 ) 0x11 0x11 0x11 0x11 0 4 0 1 Format $ t0 $ f2 $ t0 0 0 $ f2 $ f2 $ f2 0 0 $ f4 $ f4 0 0 6 6 FP Convert Instructions  Convert instruction : cvt.x.y  Convert to destination format x from source format y  Supported formats  Single precision float = .s ( single precision float in FP register )  Double precision float = .d ( double float in even-odd FP register )  Signed integer word = .w ( signed integer in FP register ) Instruction cvt.s.w fd , fs cvt.s.d fd , fs cvt.d.w fd , fs cvt.d.s fd , fs cvt.w.s fd , fs cvt.w.d fd , fs Meaning to single from integer to single from double to double from integer to double from single to integer from single to integer from double 0x11 0x11 0x11 0x11 0x11 0x11 0 1 0 1 0 1 Format fs5 0 fs5 0 fs5 0 fs5 0 fs5 0 fs5 0 fd5 fd5 fd5 fd5 fd5 fd5 0x20 0x20 0x21 0x21 0x24 0x24 FP Compare and Branch Instructions  FP unit ( co-processor 1 ) has a condition flag  Set to 0 ( false ) or 1 ( true ) by any comparison instruction  Three comparisons : equal , less than , less than or equal  Two branch instructions based on the condition flag Instruction c.eq.s fs , ft c.eq.d fs , ft fs , ft c.lt.s fs , ft c.lt.d fs , ft c.le.s c.le.d fs , ft bc1f bc1t Label Label Meaning cflag = ( ( fs ) == ( ft ) ) cflag = ( ( fs ) == ( ft ) ) cflag = ( ( fs ) < = ( ft ) ) cflag = ( ( fs ) < = ( ft ) ) cflag = ( ( fs ) < = ( ft ) ) cflag = ( ( fs ) < = ( ft ) ) branch if ( cflag == 0 ) branch if ( cflag == 1 ) 0x11 0x11 0x11 0x11 0x11 0x11 0x11 0x11 Format ft5 fs5 ft5 fs5 ft5 fs5 ft5 fs5 ft5 fs5 ft5 fs5 0 1 0 1 0 1 0 1 8 8 0x32 0x32 0x3c 0x3c 0x3e 0x3e 0 0 0 0 0 0 im16 im16 FP Data Directives .FLOAT Directive Stores the listed values as single-precision floating point .DOUBLE Directive Stores the listed values as double-precision floating point Examples var1 : .FLOAT 12.3 , -0.1 var2 : .DOUBLE 1.5e-10 pi : .DOUBLE 3.1415926535897924 Syscall Services Service $ v0 Arguments / Result Print Integer Print Float Print Double Print String Read Integer Read Float Read Double Read String 1 2 3 4 5 6 7 8 Exit Program Print Char Read Char 10 11 12 $ a0 = integer value to print $ f12 = float value to print $ f12 = double value to print $ a0 = address of null-terminated string $ v0 = integer read $ f0 = float read $ f0 = double read $ a0 = address of input buffer $ a1 = maximum number of characters to read $ a0 = character to print $ a0 = character read Supported by MARS FP Example : °F to °C • C code : float f2c ( float fahr ) { return ( ( 5.0/9.0 ) * ( fahr - 32.0 ) ) ; } – fahr in $ f12 , result in $ f0 , literals in global memory space • Compiled MIPS code : f2c : lwc1 $ f16 , const5 ( $ gp ) lwc2 $ f18 , const9 ( $ gp ) div.s $ f16 , $ f16 , $ f18 lwc1 $ f18 , const32 ( $ gp ) sub.s $ f18 , $ f12 , $ f18 mul.s $ f0 , $ f16 , $ f18 jr $ ra Lec 14 Systems Architecture 38