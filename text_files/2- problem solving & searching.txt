PROBLEM SOLVING & SEARCH STRATEGY Part 1 Dr. Emad Natsheh Problem solving Problem Description • Components ✓State space ✓Initial state ✓Goal state ✓Actions ( operators ) ✓Path cost States • A problem is defined by its elements and their relations • A state is a representation of those elements in a given moment . • Two special states are defined : • Initial state ( starting point ) • Goal state State Modification : Successor Function • A successor function is needed to move between different states . • A successor function is a description of possible actions a set of operators . It is a transformation function on a state representation , which move it into another state . • The successor function defines a relation of accessibility among states . State space • The state space is the set of all states reachable from the initial state • Its form a graph ( or tree ) in which the nodes are states and the arcs between nodes are actions . • A path in the state space is a sequence of states connected by a sequence of actions . • The solution of the problem is part of the map formed by the state space . Tree vs Graph Problem Solution • A solution in the state space is a path from the initial state to a goal state • Path/solution cost : function that assigns a numeric cost to each path , the cost of applying the operators to the states • Solution quality is measured by the path cost function , and an optimal solution has the lowest path cost among all solutions . Example 8-puzzle Example : Travelling Problem Representation Example Water Jug Problem Problem Description Operations ( Actions ) # 1 2 3 4 5 6 7 8 Actions Fill X from Pump Fill Y from Pump Empty X into Ground Empty Y into Ground Get water from Y into X until X is full Get water from X into Y until Y is full Get all water from Y into X Get all water from X into Y Rules Rules # 1 2 3 4 5 6 7 8 Another Solution to the Water Jug Problem Algorithm for Problem Solving Initialize the search tree using the initial state of the problem 1 . 2 . Choose a terminal node for expansion according to certain search strategy ❑If no terminal node is available for expansion return failure ❑If the chosen node contains a goal return the node 3 . Expand the chosen node ( according to the rules ) and add the resulting node to the search tree 4 . Go to step 2 Missionaries & Cannibals Problem Problem Description • State ( # of missionaries Left , # of cannibals Left , # of missionaries Right , # of cannibals Right , side_of_the_boat ) • Initial State = > State ( 3 , 3 , 0 , 0 , 0 ) • Final State = > State ( 0 , 0 , 3 , 3 , 1 ) . • Actions • Carry ( 2 , 0 ) . • Carry ( 1 , 0 ) . • Carry ( 1 , 1 ) . • Carry ( 0 , 1 ) . • Carry ( 0 , 2 ) . Where Carry ( M , C ) means the boat will carry M missionaries and C cannibals on one trip . Rules Rules # 1 One missionaries can move only when _________ in one side And _________ in the other 2 Two missionaries can move only when ________in one side And _________ in the other 3 One cannibals can move only when ___________ in one side And _________ in the other 4 Two cannibals can move only when ___________in one side And ________ in the other 5 One missionary and one cannibal can move only when ________ in one side And ________ in the other Vacuum Cleaner • World state space • State • Actions • Goal • Path costs : PROBLEM SOLVING & SEARCH STRATEGY Part 2 Dr. Emad Natsheh Traveling Salesman Problem Traveling Salesman Problem Traveling Salesman Problem Search Technique Search Search Technique Breadth First Search Breadth First Search •Implementation : FIFO queue •Strategy : expand a shallowest node first Breadth First Search ( Example ) Breadth First Search ( Example ) BFS Analysis • Complete ? • Optimal ? Time vs Space Complexity • Time Complexity : • It is the amount of time need to generate the nodes • Space Complexity : • It is the amount of space or memory required for getting a solution • Big O notation • Is a mathematical notation that describes the limiting behavior of a function • Used in Computer Science to describe the performance or complexity of an algorithm Branching Factor • The branching factor of a node in a tree is the number of children it has . BFS Time and Space Complexity BFS Time and Space Complexity 1 + 𝑏 + 𝑏2 + 𝑏3 + ⋯ + 𝑏𝑑 = 𝑂 ( 𝑏𝑑 ) BFS Analysis • Time Complexity → • Space Complexity → O ( 𝑏𝑑 ) • Where b is branching factor and d is depth of solution 1 + 𝑏 + 𝑏2 + 𝑏3 + ⋯ + 𝑏𝑑 = 𝑂 ( 𝑏𝑑 ) BFS Analysis Depth First Search Depth First Search • Implementation : LIFO stack , queue • Strategy : find the deepest solution Depth First Search ( Example- Stack ) Depth First Search ( Example- Queue ) Depth First Search ( Example ) DFS Analysis • Complete ? • Optimal ? DFS Time and Space Complexity ( Stack ) DFS Time and Space Complexity ( Queue ) DFS Analysis • Time Complexity → O ( 𝑏𝑚 ) • Stack • Space Complexity → O ( m ) • Queue • Space Complexity → O ( bm ) • Where b is branching factor and m is maximum depth Quiz : DFS vs BFS • When will BFS outperform DFS ? • When will DFS outperform BFS ? Iterative Deepening Depth First Search Iterative Deepening Depth First Search • Its depth-limited version of depth-first search is run repeatedly with increasing depth limits until the goal is found . • Find the shallowest solution IDDFS ( Example depth=0 ) IDDFS ( Example depth=1 ) IDDFS ( Example depth=2 ) IDDFS Pseudocode IDDFS Analysis • Complete ? • Optimal ? IDDFS Time Complexity 𝑑 + 1 + 𝑑 𝑏 + 𝑑 − 1 𝑏2 + ⋯ + 3𝑏𝑑−2 + 2𝑏𝑑−1 + 𝑏𝑑 𝑑 ( 𝑑 + 1 − 𝑖 ) 𝑏𝑖 = ෍ 𝑖=0 IDDFS Space Complexity IDDFS Analysis • Time Complexity → O ( 𝑏𝑑 ) • Stack • Space Complexity → O ( d ) • Queue • Space Complexity → O ( bd ) • Where b is branching factor and d is depth of solution Uniform Cost Search UCS ( Branch and Bound Search ) • Implementation : priority queue ( sort by cost function g ( n ) ) • g ( n ) is cost from root node to current node n • Uniform cost search vs Dijkstra ! ! ! ! UCS ( Example Table ) Visited Nodes ( Close ) Priority Queue ( Open ) - A UCS ( Example Tree ) Class Exercise Class Exercise ( Solution Table ) Visited Nodes ( Close ) Priority Queue ( Open ) - S Class Exercise ( Solution Tree ) UCS Pseudocode UCS Analysis • Complete ? • Optimal ? UCS Analysis • Time Complexity • O ( 𝑏𝑑 ) • O ( 𝑏 Τ𝐶∗ ɛ ) • Space Complexity • O ( 𝑏𝑑 ) • O ( 𝑏 Τ𝐶∗ ɛ ) UCS and 8 puzzle PROBLEM SOLVING & SEARCH STRATEGY Part 3 Dr. Emad Natsheh Informed ( Heuristic ) Search Technique Informed search • Heuristic • Best First Search ( Greedy search ) • A * Recap : Search • Search problem • State • Action or cost • Successor function • Start goal and end goal • Represent problem as tree/graph • Search algorithm • Choose node for expanding • Blind search • Inform search Informed Search Heuristic Function h ( n ) • Heuristic h ( n ) is a function that estimates how close a state is to a goal • Designed for a particular search problem • We assume that h ( n ) is non-negative , and that h ( n ) =0 if n is a goal node . Heuristic Function ( Example - Travel Planning ) Heuristic Function ( Example- 8Puzzle ) Heuristic Function ( Example- 8Puzzle ) Best First Search ( Greedy search ) Best First Search • Implementation : priority queue • Very similar to UCS but sort the queue regarding to the h ( n ) • Strategy : expand the node that you think is closest to the goal BFS Pseudocode Best First Search ( Example ) Best First Search ( Example ) cont . Path find cost =450 Optimal path cost = 418 Best First Search Analysis • Complete ? BFS Pseudocode 2 Best First Search Analysis • Optimal ? • A Common case • Best first takes you straight to the ( wrong ) goal Best First Search Analysis • Time Complexity → O ( 𝑏𝑑 ) • Space Complexity → O ( 𝑏𝑑 ) • Where b is branching factor and d is depth of solution • But a good heuristic can give dramatic improvement How can we fix the greedy problem ? A * Search A * was created as part of the Shakey project IEEE Milestones Award A * • Optimize form Best first search • Implementation : priority queue ( cost + heuristic ) • F ( n ) =g ( n ) +h ( n ) A * A * Pseudocode A * ( Example1-Table ) Close Open S A * ( Example1-Tree ) A * ( Example2-Table ) Close Open A A * ( Example2-Tree ) A * ( Path Finding Example ) A * ( 8 puzzle Example ) Manhattan Distance 𝑥1 − 𝑥2 + |𝑦1 − 𝑦2| Maze World A * ( Maze Example ) Is A * Optimal ? • What went wrong ? Admissible Heuristic Admissible Heuristic ( Example ) H ( n ) < = distance to goal ( n ) H ( n ) distance to goal ( n ) State ( n ) S A B C D G Admissibility Consistency of Heuristic ( Monotonicity ) • Main idea : estimated heuristic costs < = actual costs • Admissibility : heuristic cost < =actual cost to goal • H ( A ) < = actual cost from A to G • Consistency : heuristic “ arc ’ ’ cost < = actual cost for each arc • H ( A ) -H ( C ) < = cost ( A to C ) • Consequences of consistency • The f value along a path never decreases Monotonic Heuristic ( Example ) If it ’ s monotonic then it ’ s admissible H ( n ) < = h ( n ’ ) +c ( n-n ’ ) H ( n ) H ( n ’ ) C ( n-n ’ ) H ( n ’ ) +c ( n-n ’ ) n-n ’ S-A S-G A-B A-C B-D C-D C-G D-G Optimality • Tree Search • A * is optimal if heuristic is admissible • Graph Search • A * is optimal if heuristic is consistent • Consistency implies admissibility Hill Climbing on a surface of states Hill Climbing ( Local Search ) • It is an iterative algorithm that starts with an arbitrary solution to a problem , then attempts to find a better solution by incrementally changing a single element of the solution . If the change produces a better solution , an incremental change is made to the new solution , repeating until no further improvements can be found . • In many optimization problems , the path to the goal I irrelevant ; the goal state itself is the solution • In such cases , we can use local search algorithms • Keep single “ current ” state , try to improve it N Queen Problem • The N Queen is the problem of placing N chess queens on an N×N chessboard so that no two queens attack each other • Example 4 Queen Hill Climbing Pseudocode Hill Climbing Example Drawbacks of hill climbing Example 1 Example 2 Example 3 Example 4 Hill Climbing Analysis • Complete ? • Optimal ? • Time Complexity • Space Complexity Simulated Annealing Anneal • To subject ( glass or metal ) to a process of heating and slow cooling in order to toughen and reduce brittleness . Pseudocode of Simulated Annealing Simulated annealing algorithm https : //toddwschneider.com/posts/traveling-salesman-with- simulated-annealing-r-and-shiny/ Beam Search • Beam search is a heuristic search algorithm that explores a graph by expanding the most promising node in a limited set . • Beam search is an optimization of breadth-first search that reduces its memory requirements . • A beam search is most often used to maintain tractability in large systems with insufficient amount of memory to store the entire search tree . For example , it has been used in many machine translation systems . Machine Translation ( Seq to Seq ) • • Input the encoded input sentence to the decoder ; the decoder will then apply softmax function to all the 10,000 words in the vocabulary . From 10,000 possibilities , we will select only the top 3 words with the highest probability . Machine Translation ( Seq to Seq ) Beam Search Beam Search Example Beam Search Example Pseudocode of Beam Search Beam Search Analysis • Complete ? • Optimal ? • Time Complexity • Space Complexity Class Exercise 1 Class Exercise 1 Class Exercise 2 Class Exercise 3 • Assume you have the following Maze environment , and you want to help the slug to reach here food as soon as possible . Which among the following algorithm is the best to use : Breadth-First Search , A-star , or Greedy search . Explain your result by showing the sequence of tested node ( In- order ) ? • The slug can only move up , down , left , or right . Any of these actions can only be performed on condition that the resulting state remains within the maze and that the resulting state is not a black cell . Also , actions that bring you back to a previous state are not allowed . Note : Assume that ties are broken alphabetically ( alphabetical order of the labels in the cells ) .