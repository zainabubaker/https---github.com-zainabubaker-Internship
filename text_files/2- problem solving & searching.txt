PROBLEM SOLVING & SEARCH STRATEGY Part 1 Dr. Emad Natsheh Problem solving Problem Description â€¢ Components âœ“State space âœ“Initial state âœ“Goal state âœ“Actions ( operators ) âœ“Path cost States â€¢ A problem is defined by its elements and their relations â€¢ A state is a representation of those elements in a given moment . â€¢ Two special states are defined : â€¢ Initial state ( starting point ) â€¢ Goal state State Modification : Successor Function â€¢ A successor function is needed to move between different states . â€¢ A successor function is a description of possible actions a set of operators . It is a transformation function on a state representation , which move it into another state . â€¢ The successor function defines a relation of accessibility among states . State space â€¢ The state space is the set of all states reachable from the initial state â€¢ Its form a graph ( or tree ) in which the nodes are states and the arcs between nodes are actions . â€¢ A path in the state space is a sequence of states connected by a sequence of actions . â€¢ The solution of the problem is part of the map formed by the state space . Tree vs Graph Problem Solution â€¢ A solution in the state space is a path from the initial state to a goal state â€¢ Path/solution cost : function that assigns a numeric cost to each path , the cost of applying the operators to the states â€¢ Solution quality is measured by the path cost function , and an optimal solution has the lowest path cost among all solutions . Example 8-puzzle Example : Travelling Problem Representation Example Water Jug Problem Problem Description Operations ( Actions ) # 1 2 3 4 5 6 7 8 Actions Fill X from Pump Fill Y from Pump Empty X into Ground Empty Y into Ground Get water from Y into X until X is full Get water from X into Y until Y is full Get all water from Y into X Get all water from X into Y Rules Rules # 1 2 3 4 5 6 7 8 Another Solution to the Water Jug Problem Algorithm for Problem Solving Initialize the search tree using the initial state of the problem 1 . 2 . Choose a terminal node for expansion according to certain search strategy â‘If no terminal node is available for expansion return failure â‘If the chosen node contains a goal return the node 3 . Expand the chosen node ( according to the rules ) and add the resulting node to the search tree 4 . Go to step 2 Missionaries & Cannibals Problem Problem Description â€¢ State ( # of missionaries Left , # of cannibals Left , # of missionaries Right , # of cannibals Right , side_of_the_boat ) â€¢ Initial State = > State ( 3 , 3 , 0 , 0 , 0 ) â€¢ Final State = > State ( 0 , 0 , 3 , 3 , 1 ) . â€¢ Actions â€¢ Carry ( 2 , 0 ) . â€¢ Carry ( 1 , 0 ) . â€¢ Carry ( 1 , 1 ) . â€¢ Carry ( 0 , 1 ) . â€¢ Carry ( 0 , 2 ) . Where Carry ( M , C ) means the boat will carry M missionaries and C cannibals on one trip . Rules Rules # 1 One missionaries can move only when _________ in one side And _________ in the other 2 Two missionaries can move only when ________in one side And _________ in the other 3 One cannibals can move only when ___________ in one side And _________ in the other 4 Two cannibals can move only when ___________in one side And ________ in the other 5 One missionary and one cannibal can move only when ________ in one side And ________ in the other Vacuum Cleaner â€¢ World state space â€¢ State â€¢ Actions â€¢ Goal â€¢ Path costs : PROBLEM SOLVING & SEARCH STRATEGY Part 2 Dr. Emad Natsheh Traveling Salesman Problem Traveling Salesman Problem Traveling Salesman Problem Search Technique Search Search Technique Breadth First Search Breadth First Search â€¢Implementation : FIFO queue â€¢Strategy : expand a shallowest node first Breadth First Search ( Example ) Breadth First Search ( Example ) BFS Analysis â€¢ Complete ? â€¢ Optimal ? Time vs Space Complexity â€¢ Time Complexity : â€¢ It is the amount of time need to generate the nodes â€¢ Space Complexity : â€¢ It is the amount of space or memory required for getting a solution â€¢ Big O notation â€¢ Is a mathematical notation that describes the limiting behavior of a function â€¢ Used in Computer Science to describe the performance or complexity of an algorithm Branching Factor â€¢ The branching factor of a node in a tree is the number of children it has . BFS Time and Space Complexity BFS Time and Space Complexity 1 + ğ‘ + ğ‘2 + ğ‘3 + â‹¯ + ğ‘ğ‘‘ = ğ‘‚ ( ğ‘ğ‘‘ ) BFS Analysis â€¢ Time Complexity â†’ â€¢ Space Complexity â†’ O ( ğ‘ğ‘‘ ) â€¢ Where b is branching factor and d is depth of solution 1 + ğ‘ + ğ‘2 + ğ‘3 + â‹¯ + ğ‘ğ‘‘ = ğ‘‚ ( ğ‘ğ‘‘ ) BFS Analysis Depth First Search Depth First Search â€¢ Implementation : LIFO stack , queue â€¢ Strategy : find the deepest solution Depth First Search ( Example- Stack ) Depth First Search ( Example- Queue ) Depth First Search ( Example ) DFS Analysis â€¢ Complete ? â€¢ Optimal ? DFS Time and Space Complexity ( Stack ) DFS Time and Space Complexity ( Queue ) DFS Analysis â€¢ Time Complexity â†’ O ( ğ‘ğ‘š ) â€¢ Stack â€¢ Space Complexity â†’ O ( m ) â€¢ Queue â€¢ Space Complexity â†’ O ( bm ) â€¢ Where b is branching factor and m is maximum depth Quiz : DFS vs BFS â€¢ When will BFS outperform DFS ? â€¢ When will DFS outperform BFS ? Iterative Deepening Depth First Search Iterative Deepening Depth First Search â€¢ Its depth-limited version of depth-first search is run repeatedly with increasing depth limits until the goal is found . â€¢ Find the shallowest solution IDDFS ( Example depth=0 ) IDDFS ( Example depth=1 ) IDDFS ( Example depth=2 ) IDDFS Pseudocode IDDFS Analysis â€¢ Complete ? â€¢ Optimal ? IDDFS Time Complexity ğ‘‘ + 1 + ğ‘‘ ğ‘ + ğ‘‘ âˆ’ 1 ğ‘2 + â‹¯ + 3ğ‘ğ‘‘âˆ’2 + 2ğ‘ğ‘‘âˆ’1 + ğ‘ğ‘‘ ğ‘‘ ( ğ‘‘ + 1 âˆ’ ğ‘– ) ğ‘ğ‘– = à· ğ‘–=0 IDDFS Space Complexity IDDFS Analysis â€¢ Time Complexity â†’ O ( ğ‘ğ‘‘ ) â€¢ Stack â€¢ Space Complexity â†’ O ( d ) â€¢ Queue â€¢ Space Complexity â†’ O ( bd ) â€¢ Where b is branching factor and d is depth of solution Uniform Cost Search UCS ( Branch and Bound Search ) â€¢ Implementation : priority queue ( sort by cost function g ( n ) ) â€¢ g ( n ) is cost from root node to current node n â€¢ Uniform cost search vs Dijkstra ! ! ! ! UCS ( Example Table ) Visited Nodes ( Close ) Priority Queue ( Open ) - A UCS ( Example Tree ) Class Exercise Class Exercise ( Solution Table ) Visited Nodes ( Close ) Priority Queue ( Open ) - S Class Exercise ( Solution Tree ) UCS Pseudocode UCS Analysis â€¢ Complete ? â€¢ Optimal ? UCS Analysis â€¢ Time Complexity â€¢ O ( ğ‘ğ‘‘ ) â€¢ O ( ğ‘ Î¤ğ¶âˆ— É› ) â€¢ Space Complexity â€¢ O ( ğ‘ğ‘‘ ) â€¢ O ( ğ‘ Î¤ğ¶âˆ— É› ) UCS and 8 puzzle PROBLEM SOLVING & SEARCH STRATEGY Part 3 Dr. Emad Natsheh Informed ( Heuristic ) Search Technique Informed search â€¢ Heuristic â€¢ Best First Search ( Greedy search ) â€¢ A * Recap : Search â€¢ Search problem â€¢ State â€¢ Action or cost â€¢ Successor function â€¢ Start goal and end goal â€¢ Represent problem as tree/graph â€¢ Search algorithm â€¢ Choose node for expanding â€¢ Blind search â€¢ Inform search Informed Search Heuristic Function h ( n ) â€¢ Heuristic h ( n ) is a function that estimates how close a state is to a goal â€¢ Designed for a particular search problem â€¢ We assume that h ( n ) is non-negative , and that h ( n ) =0 if n is a goal node . Heuristic Function ( Example - Travel Planning ) Heuristic Function ( Example- 8Puzzle ) Heuristic Function ( Example- 8Puzzle ) Best First Search ( Greedy search ) Best First Search â€¢ Implementation : priority queue â€¢ Very similar to UCS but sort the queue regarding to the h ( n ) â€¢ Strategy : expand the node that you think is closest to the goal BFS Pseudocode Best First Search ( Example ) Best First Search ( Example ) cont . Path find cost =450 Optimal path cost = 418 Best First Search Analysis â€¢ Complete ? BFS Pseudocode 2 Best First Search Analysis â€¢ Optimal ? â€¢ A Common case â€¢ Best first takes you straight to the ( wrong ) goal Best First Search Analysis â€¢ Time Complexity â†’ O ( ğ‘ğ‘‘ ) â€¢ Space Complexity â†’ O ( ğ‘ğ‘‘ ) â€¢ Where b is branching factor and d is depth of solution â€¢ But a good heuristic can give dramatic improvement How can we fix the greedy problem ? A * Search A * was created as part of the Shakey project IEEE Milestones Award A * â€¢ Optimize form Best first search â€¢ Implementation : priority queue ( cost + heuristic ) â€¢ F ( n ) =g ( n ) +h ( n ) A * A * Pseudocode A * ( Example1-Table ) Close Open S A * ( Example1-Tree ) A * ( Example2-Table ) Close Open A A * ( Example2-Tree ) A * ( Path Finding Example ) A * ( 8 puzzle Example ) Manhattan Distance ğ‘¥1 âˆ’ ğ‘¥2 + |ğ‘¦1 âˆ’ ğ‘¦2| Maze World A * ( Maze Example ) Is A * Optimal ? â€¢ What went wrong ? Admissible Heuristic Admissible Heuristic ( Example ) H ( n ) < = distance to goal ( n ) H ( n ) distance to goal ( n ) State ( n ) S A B C D G Admissibility Consistency of Heuristic ( Monotonicity ) â€¢ Main idea : estimated heuristic costs < = actual costs â€¢ Admissibility : heuristic cost < =actual cost to goal â€¢ H ( A ) < = actual cost from A to G â€¢ Consistency : heuristic â€œ arc â€™ â€™ cost < = actual cost for each arc â€¢ H ( A ) -H ( C ) < = cost ( A to C ) â€¢ Consequences of consistency â€¢ The f value along a path never decreases Monotonic Heuristic ( Example ) If it â€™ s monotonic then it â€™ s admissible H ( n ) < = h ( n â€™ ) +c ( n-n â€™ ) H ( n ) H ( n â€™ ) C ( n-n â€™ ) H ( n â€™ ) +c ( n-n â€™ ) n-n â€™ S-A S-G A-B A-C B-D C-D C-G D-G Optimality â€¢ Tree Search â€¢ A * is optimal if heuristic is admissible â€¢ Graph Search â€¢ A * is optimal if heuristic is consistent â€¢ Consistency implies admissibility Hill Climbing on a surface of states Hill Climbing ( Local Search ) â€¢ It is an iterative algorithm that starts with an arbitrary solution to a problem , then attempts to find a better solution by incrementally changing a single element of the solution . If the change produces a better solution , an incremental change is made to the new solution , repeating until no further improvements can be found . â€¢ In many optimization problems , the path to the goal I irrelevant ; the goal state itself is the solution â€¢ In such cases , we can use local search algorithms â€¢ Keep single â€œ current â€ state , try to improve it N Queen Problem â€¢ The N Queen is the problem of placing N chess queens on an NÃ—N chessboard so that no two queens attack each other â€¢ Example 4 Queen Hill Climbing Pseudocode Hill Climbing Example Drawbacks of hill climbing Example 1 Example 2 Example 3 Example 4 Hill Climbing Analysis â€¢ Complete ? â€¢ Optimal ? â€¢ Time Complexity â€¢ Space Complexity Simulated Annealing Anneal â€¢ To subject ( glass or metal ) to a process of heating and slow cooling in order to toughen and reduce brittleness . Pseudocode of Simulated Annealing Simulated annealing algorithm https : //toddwschneider.com/posts/traveling-salesman-with- simulated-annealing-r-and-shiny/ Beam Search â€¢ Beam search is a heuristic search algorithm that explores a graph by expanding the most promising node in a limited set . â€¢ Beam search is an optimization of breadth-first search that reduces its memory requirements . â€¢ A beam search is most often used to maintain tractability in large systems with insufficient amount of memory to store the entire search tree . For example , it has been used in many machine translation systems . Machine Translation ( Seq to Seq ) â€¢ â€¢ Input the encoded input sentence to the decoder ; the decoder will then apply softmax function to all the 10,000 words in the vocabulary . From 10,000 possibilities , we will select only the top 3 words with the highest probability . Machine Translation ( Seq to Seq ) Beam Search Beam Search Example Beam Search Example Pseudocode of Beam Search Beam Search Analysis â€¢ Complete ? â€¢ Optimal ? â€¢ Time Complexity â€¢ Space Complexity Class Exercise 1 Class Exercise 1 Class Exercise 2 Class Exercise 3 â€¢ Assume you have the following Maze environment , and you want to help the slug to reach here food as soon as possible . Which among the following algorithm is the best to use : Breadth-First Search , A-star , or Greedy search . Explain your result by showing the sequence of tested node ( In- order ) ? â€¢ The slug can only move up , down , left , or right . Any of these actions can only be performed on condition that the resulting state remains within the maze and that the resulting state is not a black cell . Also , actions that bring you back to a previous state are not allowed . Note : Assume that ties are broken alphabetically ( alphabetical order of the labels in the cells ) .